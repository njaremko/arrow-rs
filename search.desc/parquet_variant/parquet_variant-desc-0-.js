searchState.loadedDescShard("parquet_variant", 0, "Implementation of Variant Binary Encoding from Apache …\nPrimitive (type_id=1): BINARY\nPrimitive (type_id=1): BOOLEAN (false)\nPrimitive (type_id=1): BOOLEAN (true)\nPrimitive (type_id=1): DATE\nPrimitive (type_id=1): DECIMAL(precision, scale) 128-bits\nPrimitive (type_id=1): DECIMAL(precision, scale) 32-bits\nPrimitive (type_id=1): DECIMAL(precision, scale) 64-bits\nPrimitive (type_id=1): DOUBLE\nPrimitive (type_id=1): FLOAT\nPrimitive (type_id=1): INT(16, SIGNED)\nPrimitive (type_id=1): INT(32, SIGNED)\nPrimitive (type_id=1): INT(64, SIGNED)\nPrimitive (type_id=1): INT(8, SIGNED)\nArray (type_id=4): N/A\nA builder for creating <code>Variant::List</code> values.\nPrimitive type: Null\nObject (type_id=3): N/A\nA builder for creating <code>Variant::Object</code> values.\nA Variant <code>ShortString</code>\nShort String (type_id=2): STRING\nPrimitive (type_id=1): STRING\nPrimitive (type_id=1): TIMESTAMP(isAdjustedToUTC=true, …\nPrimitive (type_id=1): TIMESTAMP(isAdjustedToUTC=false, …\nRepresents a Parquet Variant\nBuilder for <code>Variant</code> values\n<code>Variant</code> Array.\n<code>Variant</code> Metadata\nA <code>Variant</code> Object (struct with named fields).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA builder for creating <code>Variant::List</code> values.\nA builder for creating <code>Variant::Object</code> values.\nBuilder for <code>Variant</code> values\nAdd key to dictionary, return its ID\nAdd a field with key and value to the object\nFinalize object with sorted fields\nHelper to make room for header by moving data\nCreate an <code>ListBuilder</code> for creating <code>Variant::List</code> values.\nCreate an <code>ObjectBuilder</code> for creating <code>Variant::Object</code> …\nWrite little-endian integer to buffer\nUsed to unpack offset array entries such as metadata …\nDecodes a Binary from the value section of a variant.\nDecodes a Date from the value section of a variant.\nDecodes a Decimal16 from the value section of a variant.\nDecodes a Decimal4 from the value section of a variant.\nDecodes a Decimal8 from the value section of a variant.\nDecodes a Double from the value section of a variant.\nDecodes a Float from the value section of a variant.\nDecodes an Int16 from the value section of a variant.\nDecodes an Int32 from the value section of a variant.\nDecodes an Int64 from the value section of a variant.\nDecodes an Int8 from the value section of a variant.\nDecodes a long string from the value section of a variant.\nDecodes a short string from the value section of a variant.\nDecodes a TimestampMicros from the value section of a …\nDecodes a TimestampNtzMicros from the value section of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nExtracts the basic type from a header byte\nExtract the primitive type from a Variant value-metadata …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTo be used in <code>map_err</code> when unpacking an integer from a …\nBuild from the <code>offset_size_minus_one</code> bits (see spec).\nReturn one unsigned little-endian value from <code>bytes</code>.\nTo be used in <code>map_err</code> when unpacking an integer from a …\nHelper to get a &amp;str from a slice based on range, if it’…\nPerforms a binary search over a range using a fallible key …\nAttempts to prove a fallible iterator is actually …\nPrimitive (type_id=1): BINARY\nPrimitive (type_id=1): BOOLEAN (false)\nPrimitive (type_id=1): BOOLEAN (true)\nPrimitive (type_id=1): DATE\nPrimitive (type_id=1): DECIMAL(precision, scale) 128-bits\nPrimitive (type_id=1): DECIMAL(precision, scale) 32-bits\nPrimitive (type_id=1): DECIMAL(precision, scale) 64-bits\nPrimitive (type_id=1): DOUBLE\nPrimitive (type_id=1): FLOAT\nPrimitive (type_id=1): INT(16, SIGNED)\nPrimitive (type_id=1): INT(32, SIGNED)\nPrimitive (type_id=1): INT(64, SIGNED)\nPrimitive (type_id=1): INT(8, SIGNED)\nArray (type_id=4): N/A\nPrimitive type: Null\nObject (type_id=3): N/A\nA Variant <code>ShortString</code>\nShort String (type_id=2): STRING\nPrimitive (type_id=1): STRING\nPrimitive (type_id=1): TIMESTAMP(isAdjustedToUTC=true, …\nPrimitive (type_id=1): TIMESTAMP(isAdjustedToUTC=false, …\nRepresents a Parquet Variant\nConverts this variant to a <code>bool</code> if possible.\nConverts this variant to a <code>DateTime&lt;Utc&gt;</code> if possible.\nConverts this variant to tuple with a 16-byte unscaled …\nConverts this variant to tuple with a 4-byte unscaled …\nConverts this variant to tuple with an 8-byte unscaled …\nConverts this variant to an <code>f32</code> if possible.\nConverts this variant to an <code>f64</code> if possible.\nConverts this variant to an <code>i16</code> if possible.\nConverts this variant to an <code>i32</code> if possible.\nConverts this variant to an <code>i64</code> if possible.\nConverts this variant to an <code>i8</code> if possible.\nConverts this variant to a <code>List</code> if it is a <code>VariantList</code>.\nConverts this variant to a <code>NaiveDate</code> if possible.\nConverts this variant to a <code>NaiveDateTime</code> if possible.\nConverts this variant to <code>()</code> if it is null.\nConverts this variant to an <code>Object</code> if it is an …\nReturns the underlying Variant short string as a &amp;str\nConverts this variant to a <code>&amp;str</code> if possible.\nConverts this variant to a <code>&amp;[u8]</code> if possible.\nReturn the metadata associated with this variant, if any.\nAttempts to interpret <code>value</code> as a variant short string …\nCreate a new <code>Variant</code> from metadata and value.\nCreate a new variant with existing metadata\n<code>Variant</code> Array.\nA parsed version of the variant array value header byte.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIs the array of zero length\nIterates over the values of this list\nReturn the length of this array\nAttempts to interpret <code>value</code> as a variant array value.\n<code>Variant</code> Metadata\nHeader structure for <code>VariantMetadata</code>\nView the raw bytes (needed by very low-level decoders)\nGet the dictionary size\nReturns the argument unchanged.\nGets a dictionary entry by index\nGets an offset array entry by index.\nCalls <code>U::from(self)</code>.\nWhether the dictionary keys are sorted and unique\nGet all dictionary entries as an Iterator of strings\nNote: This is <code>offset_size_minus_one</code> + 1\nTries to construct the variant metadata header, which has …\nAttempts to interpret <code>bytes</code> as a variant metadata instance.\nThe variant protocol version\nA <code>Variant</code> Object (struct with named fields).\nHeader structure for <code>VariantObject</code>\nGet a field’s value by index in <code>0..self.len()</code>\nReturns the value of the field with the specified name, if …\nGet a field’s name by index in <code>0..self.len()</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns true if the object contains no key-value pairs\nReturns an iterator of (name, value) pairs over the fields …\nReturns the number of key-value pairs in this object\nAttempts to interpret <code>value</code> as a variant object value.")